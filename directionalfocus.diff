diff --git a/dwm.c b/dwm.c
index 5e4d494..3fbcf13 100644
--- a/dwm.c
+++ b/dwm.c
@@ -169,6 +169,10 @@ static void focus(Client *c);
 static void focusin(XEvent *e);
 static void focusmon(const Arg *arg);
 static void focusstack(const Arg *arg);
+static void focusup(const Arg *arg);
+static void focusright(const Arg *arg);
+static void focusdown(const Arg *arg);
+static void focusleft(const Arg *arg);
 static Atom getatomprop(Client *c, Atom prop);
 static int getrootptr(int *x, int *y);
 static long getstate(Window w);
@@ -2150,3 +2154,85 @@ main(int argc, char *argv[])
 	XCloseDisplay(dpy);
 	return EXIT_SUCCESS;
 }
+
+void
+focusdown(const Arg *arg){
+	Client *c = selmon->sel;
+	int targetX = c->x;
+	int targetY = c->y + c->h + selmon->gappih; 
+	Client * iter; 
+
+	if((c->y + c->h + selmon->gappoh) == selmon->wh) return;
+	if(c->y == (selmon->wh +selmon->gappoh)) targetY += selmon->gappoh;
+	else					   				 targetY += selmon->gappih;
+	
+	for(iter = selmon->clients; iter != NULL; iter = iter->next){
+		if(!ISVISIBLE(iter)) continue;
+		if(iter->x >= targetX && iter->y == targetY){
+				focus(iter);
+				break;
+		}
+	}
+
+}
+
+void
+focusup(const Arg *arg){
+	Client *c = selmon->sel;
+	int targetX = c->x;
+	int targetY = c->y - selmon->gappih; 
+	Client * iter; 
+
+	if(c->y == (selmon->wy + selmon->gappoh)) return;
+	
+	targetY -= selmon->gappih;
+	
+	for(iter = selmon->clients; iter != NULL; iter = iter->next){
+		if(!ISVISIBLE(iter)) continue;
+		if(iter->x >= targetX && (iter->y + iter->h) == targetY){
+			focus(iter);
+			break;
+		}
+	}
+}
+void
+focusleft(const Arg *arg){
+	Client *c = selmon->sel;
+	int targetX = c->x - selmon->gappiv;
+	int targetY = c->y + 10; // 10 for threshold
+	Client * iter; 
+
+	if(c->x == selmon->gappov) return;
+
+	targetX -= selmon->gappiv;
+
+	for(iter = selmon->clients; iter != NULL; iter = iter->next){
+		if(!ISVISIBLE(iter)) continue;
+		if((iter->x + iter->w) == targetX && (iter->y + iter->h) >= targetY ){
+				focus(iter);
+				break;
+		}
+	}
+}
+
+void
+focusright(const Arg *arg){
+	Client *c = selmon->sel;
+	int targetX = c->x + c->w + selmon->gappiv;
+	int targetY = c->y + 10; // 10 for threshold
+	Client * iter; 
+	
+
+	if(c->x == selmon->gappov) targetX += selmon->gappov;
+	else 					   targetX += selmon->gappiv;
+	
+	if(targetX == selmon->ww) return;
+
+	for(iter = selmon->clients; iter != NULL; iter = iter->next){
+		if(!ISVISIBLE(iter)) continue;
+		if(iter->x == targetX && (iter->y + iter->h) >= targetY ){
+				focus(iter);
+				break;
+		}
+	}
+}
\ No newline at end of file
